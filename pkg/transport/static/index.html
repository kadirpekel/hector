<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <title>Hector Chat</title>
    <link rel="icon" type="image/png" href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAgAAAAIACAYAAAD0eNT6AAAACXBIWXMAAA7DAAAOwwHHb6hkAAAAGXRFWHRTb2Z0d2FyZQB3d3cuaW5rc2NhcGUub3Jnm+48GgAAGwxJREFUeJzt3VuspWd93/H/bM/MHjPj+hCDGQ9mxhCMx4APlQnYGHBjkUmU9iKkKRoTU7VVoZVQGnFVNVdV70IrAuKilWqqtMEON00vaimOlDA22G4cH8b4hKhqbMqAU8CH2K5n9jZ792K83GV79p699n7X/3ne5/l8pCUkc/H+BbJ/3/UOYkUAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAry6OiCtLHwEA5NgfEV+OiOMR8XxEfLjsOQDAPE0P/+rURwQAQIPWGn4RAAAN2sjwiwAAaMSswy8CAGDEtjL8IgAARmao4RcBADAC8xh+EQAAlZr38IsAAKhI5vCLAAAorNTwiwAAKKCG4RcBAJCktuEXAQAwRzUPvwgAgIGNZfhFAAAMYIzDLwIAYJPGPvwiAABm0NLwiwAAOI1Wh18EAMAp9DD8IgAAXtXb8IsAALrW8/CLAAC6Y/hFAAAdMfwiAICOGH4RAEBHDL8IAKAjhl8EANARwy8CAOiI4RcBAHTE8IsAADpycUT8x4hYivLjmPVZuuKst975wbPfdkeh5z8XER/a2H89ADCs/dHfN/6ly/ac9+17PvRb3//ZL3929We//NnVQ+fv/2ahW7wJgIK2lT4ACtgfEV+IiM9FxGLhW7IsX7bnvHtvft8N+y7Zfe6BN/6bN37n9iO3//Sp6/PPir+JiEMR8T8KPBu6JgDoieFfhwiAvggAemD4N0gEQD8EAC0z/JsgAqAPAoAWGf4tKhgBz0fEr4YIgLkTALTE8A9IBEDbBAAtMPxzIgKgXQKAMTP8CUQAtEkAMEaGP5kIgPYIAMbE8BckAqAtAoAxMPyVEAHQDgFAzQx/hUQAtEEAUCPDXzkRAOMnAKjNv4+IfxwRO0ofkmT5A3vOv/vm99+w/91vOftA6WNm8ZtHb7vryDPHPlLg0c/Hyf/HwL8s8GxohgCgNi9FxFtKH5FgVN/41+JNAIyXAKA2rQdAE8M/TQTAOAkAatNqADQ3/NNEAIyPAKA2rQVA08M/TQTAuAgAatNKAHQz/NNEAIyHAKA2Yw+A5Ut2n3PPH77/E+/safiniQAYBwFAbcYaAN0P/zQRAPUTANRmbAFg+NcgAqBuAoDajCUADP8GiAColwCgNrUHgOGfkQiAOgkAalNrABj+LRABUB8BQG1qCwDDPxARAHURANSmlgAw/HMgAqAeAoDalA4Awz9nIgDqIACoTakAMPyJRACUt1D6AKqyPyK+HBF3RcS5hW/JtvrP3/mBXcY/xy2XH7r+0Pn7jxR49NkR8acR8eECz4aqeANAxMnh/0JEfC4iFl/9a/dHxCci4tnkW0r+EcDSlw5+9Ohn9h78pULP7443AVCOAOjbqYZ/WokIKP2/ARAByUQAlCEA+nS64Z+WHQGlAyBCBKQTAZBPAPRlluGflhkBNQRAhAhIJwIglwDow2aHf1pWBNQSABEiIJ0IgDwCoG1DDP+0jAioKQAiREA6EQA5BECbhh7+afOOgNoCIEIEpBMBMH8CoC3zHP5p84yAGgMgQgSkEwEwXwKgDVnDP21eEVBrAESIgHQiAOZHAIxbieGfNo8IqDkAIkRAOhEA8yEAxqn08E8bOgJqD4AIEZBOBMDwBMC41DT804aMgDEEQIQISCcCYFgCYBxqHf5pQ0XAWAIgQgSkEwEwHAFQtzEM/7QhImBMARAhAtKJABiGAKjT2IZ/2lYjYGwBECEC0okA2DoBUJcxD/+0rUTAGAMgQgSkEwGwNQKgDq0M/7TNRsBYAyBCBKQTAbB5AqCsFod/2mYiYMwBECEC0okA2BwBUEbrwz9t1ggYewBEiIB0IgBmJwBy9TT802aJgBYCIEIEpBMBMBsBkKPX4Z+20QhoJQAiREA6EQAbJwDmy/C/3kYioKUAiBAB6UQAbIwAmA/Dv7bTRUBrARAhAtKJADg9ATAsw78x60VAiwEQIQLSiQBYnwAYhuGf3VoR0GoARIiAdCIA1iYAtsbwb82pIqDlAIgQAelEAJyaANgcwz+cN0ZA6wEQIQLSiQB4MwEwG8M/H9MR0EMARIiAdCIAXk8AbIzhn79JBPww+giACBGQTgTA/3dG6QMqd3FE/NuIuDkiro2I7WXPSbF8xrZtf70acVbycy+MiOtf/dce/nOOiDjj9p/+4K3v2LXn/svPOn9f6WN68JsX/OKBe557+o4fHH/hQPKjd0XEb0XENyPiWPKz4ZS8ATi1Hr/xL1+257x7b37fDfvetrj73Cvu/vqxF19Zvqz0UZ1Y+oODH33wpr0HP1T6kF54EwAC4I26Hv5Ldp97YPIXn3tl6XkRkEoEJBMB9E4AnGT4T0EEpBMByUQAPes9AAz/aYiAdCIgmQigV70GgOGfgQhIJwKSiQB61FsAGP5NEgHpREAyEUBvegkAwz8AEZBOBCQTAfSk9QAw/AMTAelEQDIRQC9aDQDDP0ciIJ0ISCYC6EFrAWD4k4iAdCIgmQigda0EgOEvQASkEwHJRAAtG3sAGP7CREA6EZBMBNCqsQaA4a+ICEgnApKJAFo0tgAw/JUSAelEQDIRQGvGEgCGfwREQDoRkEwE0JKxBMCjEdHLqCx/YM/5d9/8/hv2v/stZx8ofcysnnnlxPNXfvuWp19aWX5v6Vs6sfTlgx978Lf3XioCkvz9o7d9+5vPHLuuwKOfj4hDEfGXBZ5Ng8YSAI9FxMHSR8zZ6L7xr8WbgHTeBCQr/CZABDAIAVBeM8M/TQSkEwHJRABjJwDKaXL4p4mAdCIgmQhgzARAvuaHf5oISCcCkokAxkoA5Olq+KeJgHQiIJkIYIwEwPx1O/zTREA6EZBMBDA2AmB+DP8biIB0IiCZCGBMBMDwDP86REA6EZBMBDAWAmA4hn+DREA6EZBMBDAGAmDrDP8miIB0IiCZCKB2AmDzDP8WiYB0IiCZCKBmAmB2hn9AIiCdCEgmAqiVANg4wz8nIiCdCEgmAqiRADg9w59ABKQTAclEALURAOv7+R9f/muPfuL8iy4v8OzuPLN8/Jkr77r1/7y0snxp6Vt68As7znzw4Y/ceHBx4YxdpW/pxW88eNsddz577OMFHv18RPxKRNxb4NlUaqH0AZU74zMP3/63jp144enSh/TgvB27zvvOdZ/eu2f7jsdK39Kys7fvfOQrl378r7730ZuuMv65/uSqX//4ofP3Hynw6LMj4s8iwhsfXuMNwAbs3Lbw5H3XfmrXvsWz3l7qhp7444D5OHv7zkf+zS9e8/KnL3zvB0vf0jt/HEANBMAGiYBcImA4hr9OIoDSBMAMREAuEbA1hr9+IoCSBMCMREAuETA7wz8uIoBSBMAmiIBcImBjDP94iQBKEACbJAJyiYC1Gf42iACyCYAtEAG5RMDrGf72iAAyCYAtEgG5RIDhb50IIIsAGIAIyNVrBBj+fogAMgiAgYiAXD1FgOHvkwhg3gTAgERArtYjwPAjApgnATAwEZCrxQgw/EwTAcyLAJgDEZCrlQgw/KxFBDAPAmBORECuMUeA4WcjRABDEwBzJAJyjS0CDD+zEgEMSQDMmQjINYYIMPxshQhgKAIggQjIVWsEGH6GIgIYggBIIgJy1RQBhp95EAFslQBIJAJylY4Aw8+8iQC2QgAkEwG5SkSA4SeTCGCzBEABIiBXVgQYfkoRAWyGAChEBOSaZwQYfmogApiVAChIBOQaOgIMP7URAcxCABQmAnINEQGGn5qJADZKAFRABOTabAQYfsZCBLARAqASIiDXLBFg+BkjEcDpCICKiIBcp4sAw8/YiQDWIwAqIwJynSoCDD8tEQGsRQBUSATkmkTAGbFtxfDTIhHAqQiASu3ctvDkfdccPnPfrt0XlL6lBydWfn58ceGMXaXv6MFjLz7z/X/62J//6PPvuGLn4QsvEVtJPvngbUfuePbY9QUe/XxE/EpE3Fvg2axDAFTMmwBa8r/+7/P/+589+hdPPvDCT66JiO0RsfQHBz/64E17D36o9G298CaAaQKgciKAsTvF8E8TAclEABMCYAREAGN0muGfJgKSiQAiBMBoiADGYobhnyYCkokABMCIiABqtsnhnyYCkomAvgmAkREB1GaA4Z8mApKJgH4JgBESAdRg4OGfJgKSiYA+CYCREgGUMsfhnyYCkomA/giAERMBZEoa/mkiIJkI6IsAGDkRwLwVGP5pIiCZCOiHAGiACGAeCg//NBGQTAT0QQA0QgQwlIqGf5oISCYC2icAGiIC2IpKh3+aCEgmAtomABojApjVCIZ/mghIJgLaJQAaJALYiJEN/zQRkEwEtEkANEoEsJYRD/80EZBMBLRHADRMBDCtkeGfJgKSiYC2CIDGiQAaHP5pIiCZCGiHAOiACOhT48M/TQQkEwFtEACdEAH96Gj4p4mAZCJg/ARAR0RA2zod/mkiIJkIGDcB0BkR0B7D/zoiIJkIGC8B0CER0AbDvyYRkEwEjJMA6JQIGC/DvyEiIJkIGB8B0DERMC6Gf2YiIJkIGBcB0DkRUD/DvyUiIJkIGA8BgAiolOEfjAhIJgLGQQAQESKgJoZ/LkRAMhFQPwHAa0RAWYZ/7kRAMhFQNwHA6+zctvDkfdccPnPfrt0XlL6lF0+8/Dc/vOnh25/67ovPfjgizih9T+NOfPXS679z+MJLPlj6kF588sHbjtzx7LHrCzz6uTgZAfcWePYoLJQ+gLosra4cuPqeW18+duKFp0vf0otzdyzu+eHxF88L459h8fPfPXLFf/nx474ZJvmvV/369YfO33+kwKPPiYg/iwhvfNYgAHiTpdWVA1ff/Y3jIiDHudsXzzl67Y1792zf8XjpWzqx83cf/9ZVIiDPLZcfKhUBZ0fE7SECTkkAcEoiIJcISCcCkomA+ggA1iQCcomAdCIgmQioiwBgXSIglwhIJwKSiYB6CABOSwTkEgHpREAyEVAHAcCGiIBcIiCdCEgmAsoTAGyYCMglAtKJgGS3XH7o+l89f/83CzxaBIQAYEYiIJcISCcCkn398kN/RwSUIQCYmQjIJQLSiYBkIqAMAcCmiIBcIiCdCEgmAvIJADZNBOQSAelEQDIRkEsAsCUiIJcISCcCkomAPAKALRMBuURAOhGQTATkEAAMQgTkEgHpREAyETB/AoDBiIBcIiDdzt99/FtXff3H3/X78klEwHwJAAYlAnKJgHQ7f+fxO68UAXlEwPwIAAYnAnKJgHQiIJkImA8BwFyIgFwiIJ0ISCYChicAmBsRkEsEpBMByUTAsAQAcyUCcomAdCIgmQgYjgBg7kRALhGQTgQkEwHDEACkEAG5REA6EZBMBGydACCNCMglAtKJgGQiYGsEAKlEQC4RkE4EJBMBmycASCcCcomAdCIgmQjYHAFAESIglwhIJwKSiYDZCQCKEQG5REA6EZBMBMxGAFCUCMglAtKJgGQiYOMEAMWJgFwiIJ0ISCYCNkYAUIXXIuD4S39d+pYenLt98ZwHPnz4gjMXtn+v9C2d2Pk7j995xa0/+t5flT6kF//pfZ/4yFnbdz5a4NFnR8SfRsSBAs+eiQCgGkurKweuvufWl70JyPELO3ed9/B1n36bNwFpFj//3SNXeBMwX8urK8tfeurBu/bf+bWnX3hl6X2FzjgnIi4q9OwN21b6gA16LCIOlj6CHDu3LTx537Wf2rVv8ay3l76lB8++cuK5K+++5ccvvrLs77EcS185+LGjn9576S+VPqQly6sry1/9wUP3/v4T91+0tLryztL3RMTHIuJbpY9YjwCgSiIglwhIJwIGUuHwTwiAgQiADomAXCIgnQjYgoqHf0IADEQAdEoE5BIB6UTAjEYw/BMCYCACoGMiIJcISCcCNmBEwz8hAAYiADonAnKJgHQiYA0jHP4JATAQAYAISCYC0omAKSMe/gkBMBABQESIgGwiIF33EdDA8E8IgIEIAF4jAnKJgHRdRkBDwz8hAAYiAHgdEZBLBKTrJgIaHP4JATAQAcCbiIBcIiBd0xHQ8PBPCICBCABOSQTkEgHpmouADoZ/QgAMRACwJhGQSwSkayICOhr+CQEwkEcj4rLSR1CvkxFweNe+xd0iIMEzy8efu/KuW3/y0srye0rf0okTXz14/dHDey8Zxe/MT1teWVn+4pMPPPDlp45e9MrqyoWl70n00Yj4dukj1jOWANgfEV+IiM9FxGLhW6iUNwG5vAlIN6o3AR1+4594JCK+GBF/FBErhW9Z11gCYEIIsC4RkEsEpKs+Agx//cM/MbYAmBACrEkE5BIB6aqMAMM/nuGfGGsATAgBTkkE5BIB6aqJAMM/vuGfGHsATAgB3kQE5BIB6YpGgOEf7/BPtBIAE0KA1xEBuURAuvQIMPzjH/6J1gJgQgjwGhGQSwSkS4kAw9/O8E+0GgATQoCIEAHZREC6uUWA4W9v+CdaD4AJIYAISCYC0g0aAYa/3eGf6CUAJoRA50RALhGQbssRYPjbH/6J3gJgQgh0TATkEgHpNhUBhr+f4Z/oNQAmhECnREAuEZBuwxFg+Psb/oneA2BCCHRIBOQSAenWjQDD3+/wTwiA1xMCnREBuURAujdFgOE3/BMC4NSEQEdEQC4RkG7pKwc/dvQfvP2Sqwy/4Z8mANZ3cUT8XkR8JiJ2FL6FOdq5beHJ+645fOa+XbsvKH1LD362dPyZK+6+5acvr7xySelbOnHijG3bfvbz1dULSx+S6KGI+NcR8d8iYrXwLVUSABvjjUAHvAnI5U0Ac+Ib/wYJgNkIgcaJgFwigAEZ/hkJgM0RAg0TAblEAFtk+DdJAGyNEGiUCMglAtgEw79FAmAYQqBBIiCXCGCDDP9ABMCwhEBjREAuEcA6DP/ABMB8CIGGiIBcIoA3MPxzIgDmSwg0QgTkEgGE4Z87AZBDCDRABOQSAd0y/EkEQC4hMHIiIJcI6IrhTyYAyhACIyYCcomA5hn+QgRAWUJgpERALhHQJMNfmACogxAYIRGQSwQ0w/BXQgDURQiMjAjIJQJGzfBXRgDU6V1x8meIbwo/Q1y9kxFweNe+xd0iIMEzy8efu/KuW3/y0srye0rfsgnHImJf6SOS+VneSi2UPoBTeiIi/klEvCcivhIRJ8qew3qWVlcOXH33rcePnXjh6dK39OC8HbvOeei6G9+6Z/uOx0vfsgn/MiKui4j/XvqQBI9ExD+MiL8dEX8Sxr86AqBuT0XEv4iI94YQqNrJCPiGCEhy7vbFc45ee+PekUbAXRHx96LdEJgM/xUR8Z/D6/5qCYBxEAIjIAJyjTwCItoLAcM/MgJgXIRA5URArgYiIGL8IWD4R0oAjJMQqJgIyNVIBESMLwQM/8gJgHETApUSAbkaioCI+kPA8DdCALRBCFRIBORqLAIi6gsBw98YAdAWIVAZEZCrwQiIKB8Chr9RAqBNQqAiIiBXoxEQkR8Chr9xAqBtQqASIiBXwxEQMf8QMPydEAB9EAIVEAG5Go+AiOFDwPB3RgD0RQgUJgJydRABEVsPAcPfKQHQJyFQkAjI1UkERMweAoa/cwKgb0KgEBGQq6MIiDh9CBh+IkIAcNIkBC6LiK9FxHLZc/qwtLpy4Op7vvHysRMviYAE525fPOfBaw7v3b2w43+WviXJJAQ+HhF/ESd/lveTEXF5GH5CAPB6foY42dLKysV+SjjH8urK8h/+6PFHl1d/vrP0LcnujIgbIuLK8LO8TNlW+gCqtj8ivhARn4uIxcK3NG3ntoUn77v2U7v2LZ719tK3tGZ5dWX5qz946N7ff+L+dyytruwvfM5NEfFHhW+AiBAAbIwQSCAChlXZ8E8IAKohAJiFEJgzEbB1lQ7/hACgGgKAzRACcyQCNqfy4Z8QAFRDALAVQmBORMDGjWT4JwQA1RAADEEIzIEIWN/Ihn9CAFANAcCQhMDARMCbjXT4JwQA1RAAzIMQGJAIOGnkwz8hAKiGAGCehMBAeo6ARoZ/QgBQDQFABiEwgN4ioLHhnxAAVEMAkEkIbFEPEdDo8E8IAKohAChBCGxBqxHQ+PBPCACqIQAoSQhsUksR0MnwTwgAqiEAqIEQ2ISxR0Bnwz8hAKiGAKAm74qI34uT/5DcUfiWUdi5sPD9+645fOa+xd2jiYDllZXlf/fkA/d/6amjF72yurKv9D2JHoqI346IR0ofAhECgDp5IzCDsbwJ6PQbf8TJwf9inPzmv1L4FniNAKBmQmCDao4Aw2/4qZMAYAyEwAbUFgGG3/BTNwHAmAiB06ghAgy/4WccBABjJATWUSoCDL/hZ1wEAGMmBNaQGQGG3/AzTgKAFgiBU5h3BBh+w8+4CQBaIgTeYB4RYPgNP20QALRICEwZKgIMv+GnLQKAlgmBV20lAgy/4adNAoAeCIGYPQIMv+GnbQKAnuyPiH8VEf8oOv2tgY1EgOE3/PRBANCjrkNgrQgw/IafvggAetZtCExHgOE3/AC9eldEfC0iliJitZfP4sLCE5+96P1Htm/b9sPStyR/jkbEb4QvQAC8an9E/IfoLAQ6+jwcEZ+JiIUAgFMQAm19DD8AMxEC4/4YfgC2ZBICy1F+1HwMPwDJhEDdH8MPwFwJgbo+hh+AVELA8APQMSFg+AHomBAw/AB0TAgYfgA6JgQMPwAdEwKGH4COCQHDD0DHhIDhB6BjvYeA4Qega72FgOEHgCmth4DhB4B1tBYChh8AZjD2EDD8ALAFYwsBww8AA6o9BAw/AMxRbSFg+AEgUekQMPwAUFB2CBh+AKjIvEPA8ANAxYYOAcMPACOy1RAw/AAwYrOGgOEHgIacLgQMPwA07I0hYPgBoCPvjoi/GxHbSh8CAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAJ/h8NyzauD5e0MgAAAABJRU5ErkJggg==">
    
    <!-- Markdown & Syntax Highlighting -->
    <script src="https://cdn.jsdelivr.net/npm/marked@11.1.1/marked.min.js"></script>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/styles/github-dark.min.css">
    <script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/highlight.min.js"></script>
    
    <!-- Tailwind CSS - Utility-first CSS Framework -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            darkMode: 'class',
            theme: {
                extend: {
                    colors: {
                        'hector-red': '#ed4267',
                        'hector-green': '#10b981',
                        'hector-dark': '#1a1a1a',
                        'hector-darker': '#2a2a2a',
                    }
                }
            }
        }
    </script>
    
    <!-- Alpine.js - Reactive UI Framework -->
    <script src="https://cdn.jsdelivr.net/npm/alpinejs@3.13.5/dist/cdn.min.js" defer></script>
    
    <!-- Force emoji animation via JavaScript -->
    <script>
        // Wait for Alpine.js to be ready
        function initEmojiAnimation() {
            // Inject animation styles directly into the page
            const style = document.createElement('style');
            style.textContent = `
                @keyframes breathe {
                    0%, 100% { transform: scale(1); }
                    50% { transform: scale(1.3); }
                }
            `;
            document.head.appendChild(style);
            
            function updateEmojiAnimations() {
                document.querySelectorAll('.emoji-icon').forEach(el => {
                    // Check data-should-animate attribute - this is what Alpine sets
                    const shouldAnimate = el.getAttribute('data-should-animate') === 'true';
                    
                    if (shouldAnimate) {
                        el.style.setProperty('animation', 'breathe 2s ease-in-out infinite', 'important');
                        el.style.setProperty('transform-origin', 'center center', 'important');
                        el.style.setProperty('display', 'inline-block', 'important');
                    } else {
                        el.style.setProperty('animation', 'none', 'important');
                        el.style.setProperty('transform-origin', 'center center', 'important');
                        el.style.setProperty('display', 'inline-block', 'important');
                    }
                });
            }
            
            // Watch for DOM changes and update animations
            const observer = new MutationObserver(function(mutations) {
                // Check if any mutations affected data-should-animate or added new emoji-icons
                let shouldUpdate = false;
                mutations.forEach(mutation => {
                    if (mutation.type === 'attributes' && mutation.attributeName === 'data-should-animate') {
                        shouldUpdate = true;
                    }
                    if (mutation.type === 'childList') {
                        mutation.addedNodes.forEach(node => {
                            if (node.nodeType === 1 && (node.classList?.contains('emoji-icon') || node.querySelector?.('.emoji-icon'))) {
                                shouldUpdate = true;
                            }
                        });
                    }
                });
                if (shouldUpdate) {
                    updateEmojiAnimations();
                }
            });
            observer.observe(document.body, { 
                childList: true, 
                subtree: true,
                attributes: true,
                attributeFilter: ['data-should-animate']
            });
            
            // Initial application
            setTimeout(updateEmojiAnimations, 100);
            // Check frequently to catch Alpine reactivity
            setInterval(updateEmojiAnimations, 150);
        }
        
        // Wait for DOM and Alpine.js
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', function() {
                setTimeout(initEmojiAnimation, 500); // Wait for Alpine to initialize
            });
        } else {
            setTimeout(initEmojiAnimation, 500);
        }
    </script>
    
    <!-- Define hectorApp function BEFORE Alpine.js runs -->
    <script>
        // Configure marked.js (will be available when script runs)
        if (typeof marked !== 'undefined') {
            marked.setOptions({
                breaks: true,
                gfm: true,
                headerIds: false,
                mangle: false
            });
        }
    </script>
    
    <style>
        /* Alpine.js x-cloak */
        [x-cloak] {
            display: none !important;
        }
        
        /* Grid background for chat area */
        .chat-grid {
            background-image: 
                linear-gradient(rgba(255, 255, 255, 0.03) 1px, transparent 1px),
                linear-gradient(90deg, rgba(255, 255, 255, 0.03) 1px, transparent 1px);
            background-size: 20px 20px;
        }
        
        /* Chat bubbles with transparency - using higher specificity instead of !important */
        .chat-bubble {
            border-radius: 0.5rem;
        }
        
        /* User chat bubbles - increased specificity to override Tailwind */
        .chat-bubble.chat-bubble-user {
            background: rgba(16, 185, 129, 0.08);
            border-left: 6px solid #10b981;
            border-top-left-radius: 0.5rem;
            border-bottom-left-radius: 0.5rem;
            border-top-right-radius: 0.5rem;
            border-bottom-right-radius: 0.5rem;
        }
        
        /* Agent chat bubbles - increased specificity to override Tailwind */
        .chat-bubble.chat-bubble-agent {
            background: rgba(42, 42, 42, 0.25);
            border-left: 6px solid #6b7280;
            border-top-left-radius: 0.5rem;
            border-bottom-left-radius: 0.5rem;
            border-top-right-radius: 0.5rem;
            border-bottom-right-radius: 0.5rem;
        }
        
        /* Elastic scrolling */
        #messages {
            overscroll-behavior-y: auto;
            -webkit-overflow-scrolling: touch;
            scroll-behavior: smooth;
        }
        
        /* Enable elastic bounce on iOS */
        @supports (-webkit-overflow-scrolling: touch) {
            #messages {
                -webkit-overflow-scrolling: touch;
            }
        }
        
        /* Base font size adjustment */
        body {
            font-size: 16px;
        }
        
        /* Custom styles for prose (markdown) and widgets */
        .prose {
            font-size: 16px;
            padding-left: 0;
            padding-right: 0;
            margin-top: 0;
            margin-bottom: 0;
        }
        
        .prose-sm {
            font-size: 16px;
        }
        
        .prose > *:first-child {
            margin-top: 0;
        }
        
        .prose > *:last-child {
            margin-bottom: 0;
        }
        
        .prose pre {
            background: rgba(0, 0, 0, 0.5);
            padding: 1rem;
            border-radius: 0.5rem;
            overflow-x: auto;
        }
        
        .prose code {
            background: rgba(0, 0, 0, 0.3);
            padding: 0.125rem 0.25rem;
            border-radius: 0.25rem;
            font-size: 0.875em;
        }
        
        /* Message text content */
        .message-text-content {
            margin: 0;
            padding-top: 0.5rem;
            padding-bottom: 0.5rem;
        }
        
        .message-text-content > *:first-child {
            margin-top: 0;
        }
        
        .message-text-content > *:last-child {
            margin-bottom: 0;
        }
        
        /* Paragraphs */
        .message-text-content p {
            margin-top: 1rem;
            margin-bottom: 1rem;
            line-height: 1.6;
        }
        
        .message-text-content p:first-child {
            margin-top: 0;
        }
        
        .message-text-content p:last-child {
            margin-bottom: 0;
        }
        
        /* Lists */
        .message-text-content ul,
        .message-text-content ol {
            margin-top: 0.75rem;
            margin-bottom: 0.75rem;
            padding-left: 1.5rem;
        }
        
        .message-text-content li {
            margin-top: 0.5rem;
            margin-bottom: 0.5rem;
            line-height: 1.6;
        }
        
        .message-text-content li:first-child {
            margin-top: 0;
        }
        
        .message-text-content li:last-child {
            margin-bottom: 0;
        }
        
        /* Headings */
        .message-text-content h1,
        .message-text-content h2,
        .message-text-content h3,
        .message-text-content h4,
        .message-text-content h5,
        .message-text-content h6 {
            margin-top: 1.5rem;
            margin-bottom: 0.75rem;
            font-weight: 600;
            line-height: 1.3;
        }
        
        .message-text-content h1:first-child,
        .message-text-content h2:first-child,
        .message-text-content h3:first-child,
        .message-text-content h4:first-child,
        .message-text-content h5:first-child,
        .message-text-content h6:first-child {
            margin-top: 0;
        }
        
        /* Blockquotes */
        .message-text-content blockquote {
            margin-top: 1rem;
            margin-bottom: 1rem;
            padding-left: 1rem;
            border-left: 3px solid rgba(255, 255, 255, 0.3);
            font-style: italic;
        }
        
        /* Horizontal rules */
        .message-text-content hr {
            margin-top: 1.5rem;
            margin-bottom: 1.5rem;
            border: none;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        /* Tables */
        .message-text-content table {
            margin-top: 1rem;
            margin-bottom: 1rem;
            width: 100%;
            border-collapse: collapse;
        }
        
        .message-text-content th,
        .message-text-content td {
            padding: 0.5rem;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .message-text-content th {
            background: rgba(0, 0, 0, 0.3);
            font-weight: 600;
        }
        
        /* Hide scrollbar for textarea but keep functionality */
        textarea::-webkit-scrollbar {
            width: 6px;
        }
        
        textarea::-webkit-scrollbar-track {
            background: transparent;
        }
        
        textarea::-webkit-scrollbar-thumb {
            background-color: rgba(255, 255, 255, 0.2);
            border-radius: 3px;
        }
        
        textarea::-webkit-scrollbar-thumb:hover {
            background-color: rgba(255, 255, 255, 0.3);
        }

        /* Widget spacing */
        .prose > .mb-2:last-child {
            margin-bottom: 0;
        }
        
        /* Fix sidebar width - Tailwind doesn't have w-70 by default */
        .w-70 {
            width: 280px;
        }
        
        /* Widget emoji animations - using class-based animation instead of !important */
        .emoji-icon {
            display: inline-block;
            transform-origin: center center;
        }
        
        .emoji-icon.animate {
            animation: breathe 2s ease-in-out infinite;
        }
        
        @keyframes breathe {
            0%, 100% { 
                transform: scale(1);
            }
            50% { 
                transform: scale(1.2);
            }
        }
        
        /* Typing indicator positioning */
        .message-container {
            position: relative;
            margin-bottom: 2.5rem;
        }
        
        .typing-indicator-container {
            position: absolute;
            bottom: -28px;
            left: 0;
            right: 0;
            display: flex;
            justify-content: center;
            pointer-events: none;
        }
    </style>
</head>
<body x-data="hectorApp()" x-init="init()" class="bg-hector-dark text-white h-screen flex overflow-hidden">
    <!-- Sidebar -->
    <div class="w-70 bg-hector-darker flex flex-col border-r border-white/10 transition-all duration-300"
         :class="{ '-translate-x-full w-0 border-r-0 overflow-hidden': !sidebarVisible }">
        <div class="bg-black/95 backdrop-blur-sm p-4 flex items-center justify-center gap-3 border-b border-white/10 h-14">
            <a href="https://gohector.dev" target="_blank" class="w-8 h-8 flex items-center justify-center transition-transform hover:scale-110" title="Hector - A2A Agent Framework">
                <img src="data:image/png;base64,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" alt="Hector" class="w-full h-full object-contain">
            </a>
        </div>

        <div class="flex-1 overflow-y-auto p-2" id="conversations">
            <template x-for="(session, sessionId) in sessions" :key="sessionId">
                <div class="group p-3 rounded-lg mb-2 cursor-pointer transition-colors hover:bg-white/5 flex items-center justify-between border-l-[6px]"
                     :class="sessionId === currentSessionId ? 'bg-white/10 border-hector-red' : 'border-transparent'">
                    <div class="flex-1 min-w-0" @click="loadSession(sessionId)">
                        <div class="text-sm font-medium truncate" x-text="session.title"></div>
                        <div class="text-xs text-gray-400 mt-1" x-text="formatTime(session.created)"></div>
                    </div>
                    <button @click.stop="deleteSession(sessionId)" 
                            class="opacity-0 group-hover:opacity-100 transition-opacity ml-2 p-1.5 hover:bg-red-500/20 rounded text-red-400 hover:text-red-300"
                            title="Delete session">
                        <svg class="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"></path>
                        </svg>
                    </button>
                </div>
            </template>
        </div>

        <div class="p-4 border-t border-white/10">
            <button class="w-full px-4 py-3 bg-hector-red hover:bg-[#c73552] rounded-lg text-white text-sm font-medium transition-all shadow-sm flex items-center justify-center gap-2"
                    @click="newChat()">
                <span>New chat</span>
            </button>
        </div>
    </div>

    <!-- Main content -->
    <div class="flex-1 flex flex-col">
        <!-- Top bar -->
        <div class="h-14 bg-hector-darker border-b border-white/10 flex items-center justify-between px-4">
            <button class="p-2 hover:bg-white/10 rounded transition-colors" @click="sidebarVisible = !sidebarVisible" title="Toggle sidebar">
                <span class="text-lg">‚ò∞</span>
            </button>
            <div class="flex-1 px-4">
                <div class="text-sm font-medium" x-text="selectedAgent?.name || 'Loading...'"></div>
                <div class="text-xs text-gray-400" x-text="selectedAgent?.description || ''"></div>
            </div>
            <div class="text-xs text-gray-500">
                Powered by <a href="https://github.com/kadirpekel/hector" target="_blank" class="hover:text-white">Hector</a> ‚Ä¢ <a href="https://a2a-protocol.org" target="_blank" class="hover:text-white">A2A</a> v0.3.0
            </div>
            <button class="p-2 hover:bg-white/10 rounded transition-colors" @click="configVisible = !configVisible">
                <span>‚öôÔ∏è</span>
            </button>
        </div>

        <!-- Config panel -->
        <div class="bg-hector-darker border-b border-white/10 p-4" x-show="configVisible" x-cloak>
            <div class="grid grid-cols-3 gap-4 mb-4">
                <div>
                    <label class="block text-sm mb-1">Endpoint URL</label>
                    <input type="text" id="endpoint" placeholder="http://localhost:8080/" class="w-full px-3 py-2 bg-black/50 border border-white/20 rounded text-sm">
                </div>
                <div>
                    <label class="block text-sm mb-1">Protocol</label>
                    <select id="transport" class="w-full px-3 py-2 bg-black/50 border border-white/20 rounded text-sm">
                        <option value="jsonrpc">JSON-RPC 2.0</option>
                        <option value="rest">REST (HTTP+JSON)</option>
                    </select>
                </div>
                <div>
                    <label class="block text-sm mb-1">Agent</label>
                    <select id="agent" class="w-full px-3 py-2 bg-black/50 border border-white/20 rounded text-sm">
                        <option value="">Loading...</option>
                    </select>
                </div>
            </div>
            <div class="flex items-center gap-2 mb-2">
                <input type="checkbox" id="streaming" checked class="rounded">
                <label for="streaming" class="text-sm">Enable streaming responses</label>
            </div>
            <div class="flex items-center gap-2">
                <input type="checkbox" id="minimalMode" class="rounded">
                <label for="minimalMode" class="text-sm">Minimal mode (hide sidebar)</label>
            </div>
        </div>

        <!-- Chat container -->
        <div class="flex-1 flex flex-col overflow-hidden chat-grid">
            <div class="flex-1 overflow-y-auto py-6" id="messages" x-show="currentMessages.length > 0" x-cloak>
                <template x-for="(message, index) in currentMessages" :key="message.id || index">
                    <div class="flex justify-center message-container" :data-message-id="message.id || ''">
                        <div class="w-full max-w-3xl px-4">
                            <div :class="message.role === 'user' ? 'chat-bubble-user' : 'chat-bubble-agent'" class="chat-bubble shadow-lg">
                                <div class="px-4 pt-4 pb-2">
                                    <div class="flex items-center justify-between text-xs text-gray-400">
                                        <span class="font-medium" x-text="message.role === 'user' ? 'You' : 'Agent'"></span>
                                        <span x-text="message.time || new Date().toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit' })"></span>
                                    </div>
                                </div>
                                <div class="px-4 pb-4 prose prose-invert prose-sm max-w-none">
                                    <!-- Widgets -->
                                    <template x-for="widget in (message.widgets || [])" :key="`widget-${widget.id}`">
                                        <div class="mb-3 rounded-lg overflow-hidden" 
                                             x-data="{ 
                                                 expanded: widget.isExpanded || false
                                             }" 
                                             x-init="widget.isExpanded = expanded;">
                                            <!-- Tool Widget -->
                                            <template x-if="widget.type === 'tool'">
                                                <div>
                                                    <button @click.stop="expanded = !expanded; widget.isExpanded = expanded" 
                                                            :class="{
                                                                'active': widget.status === 'pending' || widget.status === 'working'
                                                            }"
                                                            class="widget-toggle-btn w-full flex items-center gap-2 px-4 py-3 bg-black/30 hover:bg-black/50 transition-colors cursor-pointer">
                                                        <span class="emoji-icon" 
                                                              :class="{ 'animate': shouldBadgeAnimate(widget, message, index) }">üîß</span>
                                                        <span class="text-sm font-medium flex-1 text-left" x-text="widget.data?.name || 'unknown'"></span>
                                                        <span :class="widget.status === 'success' ? 'text-green-400' : widget.status === 'failed' ? 'text-red-400' : 'text-yellow-400'" 
                                                              class="text-sm" 
                                                              x-text="widget.status === 'success' ? '‚úì' : widget.status === 'failed' ? '‚úó' : '‚è≥'"></span>
                                                        <span class="text-xs ml-2" x-text="expanded ? '‚ñ≤' : '‚ñº'"></span>
                                                    </button>
                                                    <div x-show="expanded" 
                                                         x-transition:enter="transition ease-out duration-200"
                                                         x-transition:enter-start="opacity-0 max-h-0"
                                                         x-transition:enter-end="opacity-100 max-h-screen"
                                                         x-transition:leave="transition ease-in duration-150"
                                                         x-transition:leave-start="opacity-100 max-h-screen"
                                                         x-transition:leave-end="opacity-0 max-h-0"
                                                         class="px-4 py-3 bg-black/20 text-sm overflow-hidden">
                                                        <template x-if="widget.data?.args && Object.keys(widget.data.args).length > 0">
                                                            <div class="mb-2">
                                                                <div class="text-xs text-gray-400 mb-1">Arguments:</div>
                                                                <pre class="p-2 bg-black/50 rounded text-xs overflow-x-auto whitespace-pre-wrap" x-text="JSON.stringify(widget.data.args, null, 2)"></pre>
                                                            </div>
                                                        </template>
                                                        <template x-if="widget.content">
                                                            <div class="mt-2">
                                                                <div class="text-xs text-gray-400 mb-1">Result:</div>
                                                                <div class="whitespace-pre-wrap" x-text="widget.content"></div>
                                                            </div>
                                                        </template>
                                                    </div>
                                                </div>
                                            </template>
                                            <!-- Thinking Widget -->
                                            <template x-if="widget.type === 'thinking'">
                                                <div>
                                                    <button @click.stop="expanded = !expanded; widget.isExpanded = expanded" 
                                                            :class="{
                                                                'active': widget.status === 'active' || (isTyping && message.role === 'agent' && index === currentMessages.length - 1 && widget.status !== 'completed')
                                                            }"
                                                            class="widget-toggle-btn w-full flex items-center gap-2 px-4 py-3 bg-black/30 hover:bg-black/50 transition-colors cursor-pointer">
                                                        <span class="emoji-icon" 
                                                              :class="{ 'animate': shouldBadgeAnimate(widget, message, index) }"
                                                              x-text="getThinkingIcon(widget.data?.type || 'default')"></span>
                                                        <span class="text-sm font-medium flex-1 text-left" x-text="getThinkingLabel(widget.data?.type || 'default')"></span>
                                                        <span class="text-xs" x-text="expanded ? '‚ñ≤' : '‚ñº'"></span>
                                                    </button>
                                                    <div x-show="expanded" 
                                                         x-transition:enter="transition ease-out duration-200"
                                                         x-transition:enter-start="opacity-0 max-h-0"
                                                         x-transition:enter-end="opacity-100 max-h-screen"
                                                         x-transition:leave="transition ease-in duration-150"
                                                         x-transition:leave-start="opacity-100 max-h-screen"
                                                         x-transition:leave-end="opacity-0 max-h-0"
                                                         class="px-4 py-3 bg-black/20 text-sm whitespace-pre-wrap overflow-hidden" x-text="widget.content || ''"></div>
                                                </div>
                                            </template>
                                            <!-- Approval Widget (HITL) -->
                                            <template x-if="widget.type === 'approval'">
                                                <div class="mb-3 rounded-lg overflow-hidden bg-black/20 border border-white/10">
                                                    <div class="px-4 py-3 bg-black/30">
                                                        <div class="flex items-center gap-2 mb-3">
                                                            <span class="text-base emoji-icon" 
                                                                  :class="{ 'animate': shouldBadgeAnimate(widget, message, index) }">üîê</span>
                                                            <span class="text-sm font-medium text-gray-300">Approval Required</span>
                                                        </div>
                                                        <div class="space-y-2">
                                                            <div>
                                                                <div class="text-xs text-gray-400 mb-1">Tool</div>
                                                                <div class="text-sm text-gray-200 font-medium" x-text="widget.data?.toolName || 'Unknown'"></div>
                                                            </div>
                                                            <div>
                                                                <div class="text-xs text-gray-400 mb-1">Input</div>
                                                                <div class="bg-black/40 p-2 rounded text-xs font-mono whitespace-pre-wrap text-gray-300 break-words" x-text="widget.data?.toolInput || ''"></div>
                                                            </div>
                                                        </div>
                                                    </div>
                                                    <template x-if="widget.status === 'pending'">
                                                        <div class="px-4 py-3 border-t border-white/10 flex gap-2">
                                                            <button @click="handleApproval(widget.id, 'approve')"
                                                                    class="flex-1 px-4 py-2 bg-hector-green/80 hover:bg-hector-green rounded text-sm font-medium transition-colors text-white">
                                                                Approve
                                                            </button>
                                                            <button @click="handleApproval(widget.id, 'deny')"
                                                                    class="flex-1 px-4 py-2 bg-black/50 hover:bg-black/70 border border-white/20 rounded text-sm font-medium transition-colors text-gray-300">
                                                                Deny
                                                            </button>
                                                        </div>
                                                    </template>
                                                    <template x-if="widget.status === 'decided'">
                                                        <div class="px-4 py-3 border-t border-white/10">
                                                            <div class="text-sm font-medium flex items-center gap-2"
                                                                 :class="widget.decision === 'approve' ? 'text-hector-green' : 'text-gray-400'">
                                                                <span x-text="widget.decision === 'approve' ? '‚úì' : '‚úó'"></span>
                                                                <span x-text="widget.decision === 'approve' ? 'Approved' : 'Denied'"></span>
                                                            </div>
                                                        </div>
                                                    </template>
                                                </div>
                                            </template>
                                        </div>
                                    </template>
                                    <!-- Text Content - Show when text exists -->
                                    <div x-show="message.text && message.text.trim()" class="message-text-content mt-3" x-html="marked.parse(message.text || '')"></div>
                                </div>
                            </div>
                            <!-- Cancellation indicator - subtle text below agent bubble -->
                            <div x-show="message.role === 'agent' && message.cancelled" 
                                 x-cloak
                                 class="mt-2 px-4 text-xs text-gray-500 italic">
                                user cancelled
                            </div>
                            <!-- Typing indicator positioned absolutely below the bubble -->
                            <div x-show="isTyping && message.role === 'agent' && index === currentMessages.length - 1 && !message.cancelled" 
                                 x-cloak
                                 class="typing-indicator-container">
                                <div class="flex items-center gap-2">
                                    <div class="w-2 h-2 bg-hector-green rounded-full animate-pulse"></div>
                                    <div class="w-2 h-2 bg-hector-green rounded-full animate-pulse" style="animation-delay: 0.2s"></div>
                                    <div class="w-2 h-2 bg-hector-green rounded-full animate-pulse" style="animation-delay: 0.4s"></div>
                                </div>
                            </div>
                        </div>
                    </div>
                </template>
            </div>
        </div>

        <!-- Input area -->
        <div class="border-t border-white/10 p-4 bg-hector-dark">
            <div class="max-w-3xl mx-auto px-4">
                <div class="flex items-center gap-3">
                    <textarea x-model="inputText" 
                             @keydown.enter.prevent="!$event.shiftKey && sendMessage()"
                             :placeholder="activeTaskId || sessions[currentSessionId]?.taskId ? 'Respond to the prompt above...' : 'Type a message'" 
                             rows="1" 
                             maxlength="4000"
                             :disabled="isGenerating"
                             class="flex-1 px-4 bg-black/50 border border-white/20 rounded-lg resize-none text-sm focus:outline-none focus:ring-2 focus:ring-hector-green focus:border-hector-green disabled:opacity-50"
                             style="height: 44px; max-height: 200px; line-height: 44px; padding-top: 0; padding-bottom: 0; box-sizing: border-box; scrollbar-width: thin; scrollbar-color: rgba(255, 255, 255, 0.2) transparent;"></textarea>
                    <button @click="isGenerating ? cancelGeneration() : sendMessage()" 
                           :disabled="!isGenerating && !inputText.trim()"
                           :class="isGenerating ? 'bg-gray-700 hover:bg-gray-600 text-white' : 'bg-hector-green hover:bg-[#0d9668]'"
                           class="px-6 h-[44px] rounded-lg font-medium transition-colors disabled:opacity-50 disabled:cursor-not-allowed flex-shrink-0 flex items-center justify-center"
                           x-text="isGenerating ? '‚ñ°' : '‚û§'"></button>
                </div>
            </div>
        </div>
    </div>

    <script>
        // ============================================================================
        // Hector Web UI - Alpine.js Foundation
        // ============================================================================
        
        // Configure marked.js
        marked.setOptions({
            breaks: true,
            gfm: true,
            headerIds: false,
            mangle: false
        });
        
        // Main Alpine.js App Component
        function hectorApp() {
            return {
                // UI State
                sidebarVisible: true,
                configVisible: false,
                isTyping: false,
                isGenerating: false,
                inputText: '',
                
                // Data State
                sessions: {},
                currentSessionId: null,
                availableAgents: [],
                selectedAgent: null,
                activeTaskId: null,
                activeAbortController: null,
                
                // Computed Properties
                get currentMessages() {
                    if (!this.currentSessionId || !this.sessions[this.currentSessionId]) {
                        return [];
                    }
                    return this.sessions[this.currentSessionId].messages || [];
                },
                
                // Initialize
                init() {
                    // Handle window resize - auto-hide sidebar on small screens
                    const handleResize = () => {
                        if (window.innerWidth <= 768) {
                            this.sidebarVisible = false;
                        } else {
                            // Restore sidebar on larger screens (default to visible)
                            const stored = localStorage.getItem('hector_sidebar_visible');
                            this.sidebarVisible = stored === null ? true : stored === 'true';
                        }
                    };
                    
                    window.addEventListener('resize', handleResize);
                    handleResize(); // Initial check
                    
                    // Save sidebar visibility preference
                    this.$watch('sidebarVisible', (value) => {
                        if (window.innerWidth > 768) {
                            localStorage.setItem('hector_sidebar_visible', value.toString());
                        }
                    });
                    
                    // Clear any old cached CSS from localStorage if present
                    try {
                        const sessions = localStorage.getItem('hector_sessions');
                        if (sessions) {
                            const parsed = JSON.parse(sessions);
                            // Check if any message contains CSS code (old bug)
                            let needsCleanup = false;
                            Object.values(parsed).forEach(session => {
                                if (session.messages) {
                                    session.messages = session.messages.filter(msg => {
                                        const text = msg.text || '';
                                        // Remove messages that look like CSS
                                        if (text.includes('/* Sidebar */') || text.includes('.sidebar {')) {
                                            needsCleanup = true;
                                            return false;
                                        }
                                        return true;
                                    });
                                }
                            });
                            if (needsCleanup) {
                                localStorage.setItem('hector_sessions', JSON.stringify(parsed));
                            }
                        }
                    } catch (e) {
                        console.log('Error cleaning localStorage:', e);
                    }
                    
                    this.loadSessions();
                    this.fetchAgents();
                    this.setupMinimalMode();
                    
                    if (Object.keys(this.sessions).length === 0) {
                        this.newChat();
                    } else {
                        const sessionIds = Object.keys(this.sessions);
                        const lastSessionId = sessionIds[sessionIds.length - 1];
                        if (lastSessionId) {
                            this.loadSession(lastSessionId);
                        } else {
                            this.newChat();
                        }
                    }
                    
                    // Set endpoint default
                    const endpointInput = document.getElementById('endpoint');
                    if (!endpointInput.value) {
                        endpointInput.value = window.location.origin;
                    }
                },
                
                // Throttle streaming updates to prevent excessive re-renders
                streamingUpdateTimer: null,
                throttleStreamingUpdate(callback) {
                    if (this.streamingUpdateTimer) {
                        clearTimeout(this.streamingUpdateTimer);
                    }
                    this.streamingUpdateTimer = setTimeout(() => {
                        callback();
                        this.streamingUpdateTimer = null;
                    }, 100); // Update every 100ms max to reduce flicker
                },
                
                // Session Management
                loadSessions() {
                    try {
                        const stored = localStorage.getItem('hector_sessions');
                        if (stored) {
                            const parsed = JSON.parse(stored);
                            // Ensure sessions object is properly structured
                            if (parsed && typeof parsed === 'object' && !Array.isArray(parsed)) {
                                this.sessions = parsed;
                            } else {
                                console.warn('Invalid sessions format, resetting');
                                this.sessions = {};
                            }
                        } else {
                            this.sessions = {};
                        }
                    } catch (e) {
                        console.error('Error loading sessions:', e);
                        this.sessions = {};
                    }
                },
                
                saveSessions() {
                    localStorage.setItem('hector_sessions', JSON.stringify(this.sessions));
                },
                
                newChat() {
                    const sessionId = 'session-' + Date.now();
                    this.currentSessionId = sessionId;
                    this.sessions[sessionId] = {
                        id: sessionId,
                        title: 'New conversation',
                        created: new Date().toISOString(),
                        messages: [],
                        contextId: 'hector-web-' + Date.now(),
                        taskId: null
                    };
                    this.saveSessions();
                    this.focusInput();
                },
                
                loadSession(sessionId) {
                    if (!sessionId) {
                        console.error('No session ID provided');
                        return;
                    }
                    
                    if (!this.sessions[sessionId]) {
                        console.error('Session not found:', sessionId);
                        // Try to reload sessions from storage
                        this.loadSessions();
                        if (!this.sessions[sessionId]) {
                            console.error('Session still not found after reload:', sessionId);
                            this.newChat();
                            return;
                        }
                    }
                    
                    this.currentSessionId = sessionId;
                    const session = this.sessions[sessionId];
                    
                    // Ensure session has messages array
                    if (!session.messages) {
                        session.messages = [];
                    }
                    
                    // Ensure all messages have widgets initialized
                    session.messages.forEach(msg => {
                        // Normalize role values (handle both 'user'/'agent' and 'ROLE_USER'/'ROLE_AGENT')
                        if (msg.role === 'ROLE_USER' || msg.role === 'user') {
                            msg.role = 'user';
                        } else if (msg.role === 'ROLE_AGENT' || msg.role === 'agent') {
                            msg.role = 'agent';
                        } else if (!msg.role) {
                            // Default to agent if role is missing (for backward compatibility)
                            msg.role = 'agent';
                        }
                        
                        // Ensure message has required properties
                        if (!msg.id) {
                            msg.id = 'msg-' + Date.now() + '-' + Math.random();
                        }
                        if (msg.text === undefined || msg.text === null) {
                            msg.text = '';
                        }
                        if (!msg.widgets) {
                            msg.widgets = [];
                        }
                        if (!msg.toolCalls) {
                            msg.toolCalls = [];
                        }
                        if (!msg.thinkingBlocks) {
                            msg.thinkingBlocks = [];
                        }
                        
                        // Initialize widgets from toolCalls and thinkingBlocks if not already done
                        if (msg.widgets.length === 0) {
                            (msg.toolCalls || []).forEach(tc => {
                                msg.widgets.push({
                                    id: tc.id,
                                    type: 'tool',
                                    data: { name: tc.name, args: tc.args },
                                    status: tc.status || 'success', // Default to success for loaded messages
                                    content: tc.content || '',
                                    isExpanded: false
                                });
                            });
                            (msg.thinkingBlocks || []).forEach(tb => {
                                msg.widgets.push({
                                    id: tb.id,
                                    type: 'thinking',
                                    data: { type: tb.type },
                                    status: (tb.content && tb.content.trim()) ? 'completed' : 'active',
                                    content: tb.content || '',
                                    isExpanded: false
                                });
                            });
                        } else {
                            // Ensure existing widgets have proper status - mark completed ones
                            msg.widgets.forEach(widget => {
                                if (widget.type === 'tool' && !widget.status) {
                                    widget.status = widget.content ? 'success' : 'working';
                                }
                                if (widget.type === 'thinking') {
                                    // ALWAYS mark as completed if it has content, regardless of current status
                                    if (widget.content && widget.content.trim()) {
                                        widget.status = 'completed';
                                    } else {
                                        widget.status = 'active';
                                    }
                                }
                            });
                        }
                    });
                    
                    // Save updated session structure
                    this.saveSessions();
                    
                    // Messages are reactive, will auto-update
                    if (window.innerWidth <= 768) {
                        this.sidebarVisible = false;
                    }
                    
                    // Highlight code blocks after loading
                    this.$nextTick(() => {
                        const messagesDiv = document.getElementById('messages');
                        if (messagesDiv) {
                            messagesDiv.querySelectorAll('pre code').forEach(block => {
                                hljs.highlightElement(block);
                            });
                        }
                    });
                    
                    // Focus input when session is loaded
                    this.focusInput();
                },
                
                updateSessionTitle(sessionId, firstMessage) {
                    if (this.sessions[sessionId]?.title === 'New conversation') {
                        this.sessions[sessionId].title = firstMessage.substring(0, 30) + (firstMessage.length > 30 ? '...' : '');
                        this.saveSessions();
                    }
                },
                
                deleteSession(sessionId) {
                    if (confirm('Are you sure you want to delete this conversation?')) {
                        delete this.sessions[sessionId];
                        if (this.currentSessionId === sessionId) {
                            const remainingSessions = Object.keys(this.sessions);
                            if (remainingSessions.length > 0) {
                                this.loadSession(remainingSessions[0]);
                            } else {
                                this.newChat();
                            }
                        }
                        this.saveSessions();
                    }
                },
                
                formatTime(isoString) {
                    const date = new Date(isoString);
                    const now = new Date();
                    const diffMs = now - date;
                    const diffMins = Math.floor(diffMs / 60000);
                    
                    if (diffMins < 1) return 'Just now';
                    if (diffMins < 60) return `${diffMins}m ago`;
                    const diffHours = Math.floor(diffMins / 60);
                    if (diffHours < 24) return `${diffHours}h ago`;
                    const diffDays = Math.floor(diffHours / 24);
                    return `${diffDays}d ago`;
                },
                
                // Agent Management
                async fetchAgents() {
                    const endpointInput = document.getElementById('endpoint');
                    const endpoint = endpointInput?.value.trim() || window.location.origin;
                    
                    let baseUrl;
                    try {
                        const url = new URL(endpoint);
                        baseUrl = `${url.protocol}//${url.host}`;
                    } catch (e) {
                        baseUrl = window.location.origin;
                    }
                    
                    try {
                        const response = await fetch(`${baseUrl}/v1/agents`);
                        if (!response.ok) throw new Error(`HTTP ${response.status}`);
                        
                        const data = await response.json();
                        this.availableAgents = data.agents || [];
                        
                        const agentSelect = document.getElementById('agent');
                        const agentName = document.getElementById('agentName');
                        const agentDescription = document.getElementById('agentDescription');
                        
                        if (agentSelect) {
                            agentSelect.innerHTML = '';
                            
                            if (this.availableAgents.length === 0) {
                                agentSelect.innerHTML = '<option value="">No agents</option>';
                                this.selectedAgent = null;
                                if (agentName) agentName.textContent = 'No agents';
                                if (agentDescription) agentDescription.textContent = '';
                                return;
                            }
                            
                            this.availableAgents.forEach((agent, index) => {
                                const option = document.createElement('option');
                                option.value = index;
                                option.textContent = agent.name || 'Unknown';
                                agentSelect.appendChild(option);
                            });
                            
                            agentSelect.value = '0';
                            this.selectedAgent = this.availableAgents[0];
                        }
                    } catch (error) {
                        console.error('Failed to fetch agents:', error);
                        this.selectedAgent = null;
                    }
                },
                
                
                getThinkingIcon(type) {
                    const icons = {
                        'todo': 'üìù',
                        'goal': 'üéØ',
                        'reflection': 'üí≠',
                        'default': 'üí≠'
                    };
                    return icons[type] || icons.default;
                },
                
                getThinkingLabel(type) {
                    const labels = {
                        'todo': 'Planning',
                        'goal': 'Goal Decomposition',
                        'reflection': 'Reflection',
                        'default': 'Thinking'
                    };
                    return labels[type] || labels.default;
                },
                
                // Generic helper to determine if a badge should animate based on its lifecycle status
                shouldBadgeAnimate(widget, message, messageIndex) {
                    if (!widget || !widget.status) return false;
                    
                    // Tool widgets: animate when pending or working
                    if (widget.type === 'tool') {
                        return widget.status === 'pending' || widget.status === 'working';
                    }
                    
                    // Thinking widgets: animate when active, or when typing and it's the last message
                    if (widget.type === 'thinking') {
                        const isLastMessage = messageIndex === this.currentMessages.length - 1;
                        const isTyping = this.isTyping && message.role === 'agent' && isLastMessage;
                        return widget.status === 'active' || (isTyping && widget.status !== 'completed');
                    }
                    
                    // Approval widgets: animate when pending
                    if (widget.type === 'approval') {
                        return widget.status === 'pending';
                    }
                    
                    return false;
                },
                
                escapeHtml(text) {
                    const div = document.createElement('div');
                    div.textContent = text;
                    return div.innerHTML;
                },
                
                // Focus input textarea helper
                focusInput() {
                    this.$nextTick(() => {
                        const textarea = document.querySelector('textarea[x-model="inputText"]');
                        if (textarea) {
                            textarea.focus();
                        }
                    });
                },
                
                
                // Highlight code blocks
                highlightCode(element) {
                    element.querySelectorAll('pre code').forEach((block) => {
                        hljs.highlightElement(block);
                    });
                },
                
                // Message Sending
                async sendMessage() {
                    if (!this.inputText.trim()) return;
                    
                    const endpointInput = document.getElementById('endpoint');
                    const endpoint = endpointInput?.value.trim();
                    if (!endpoint) {
                        this.showError('Please enter an endpoint URL');
                        return;
                    }
                    
                    const agentSelect = document.getElementById('agent');
                    const agentIndex = parseInt(agentSelect?.value);
                    const agent = this.availableAgents[agentIndex];
                    
                    if (!agent || !agent.url) {
                        this.showError('No agent selected or agent URL not available');
                        return;
                    }
                    
                    const messageText = this.inputText.trim();
                    
                    // Add user message
                    this.addMessage('user', messageText);
                    
                    if (this.currentSessionId) {
                        this.updateSessionTitle(this.currentSessionId, messageText);
                    }
                    
                    this.inputText = '';
                    this.isGenerating = true;
                    
                    try {
                        // Check if we're resuming a human-in-the-loop prompt
                        const session = this.sessions[this.currentSessionId];
                        const taskId = this.activeTaskId || session?.taskId;
                        
                        if (taskId) {
                            // Resuming a task - send response with taskId
                            await this.sendStreamingMessage(agent.url, messageText, taskId);
                        } else {
                            // New message
                            await this.sendStreamingMessage(agent.url, messageText);
                        }
                    } catch (error) {
                        console.error('Error:', error);
                        this.showError('Error: ' + error.message);
                    } finally {
                        this.isGenerating = false;
                    }
                },
                
                addMessage(role, text, metadata = {}, toolCalls = [], thinkingBlocks = []) {
                    if (!this.currentSessionId) {
                        this.newChat();
                    }
                    
                    const message = {
                        id: 'msg-' + Date.now() + '-' + Math.random(),
                        role,
                        text,
                        metadata,
                        toolCalls,
                        thinkingBlocks,
                        widgets: [], // Initialize widgets array
                        time: new Date().toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit' })
                    };
                    
                    // Initialize widgets from toolCalls and thinkingBlocks
                    toolCalls.forEach(tc => {
                        message.widgets.push({
                            id: tc.id,
                            type: 'tool',
                            data: { name: tc.name, args: tc.args },
                            status: tc.status || 'working',
                            content: '',
                            isExpanded: false
                        });
                    });
                    
                    thinkingBlocks.forEach(tb => {
                        message.widgets.push({
                            id: tb.id,
                            type: 'thinking',
                            data: { type: tb.type },
                            status: (tb.content && tb.content.trim()) ? 'completed' : 'active',
                            content: tb.content || '',
                            isExpanded: false
                        });
                    });
                    
                    this.sessions[this.currentSessionId].messages.push(message);
                    this.saveSessions();
                    
                    // Auto-scroll
                    this.$nextTick(() => {
                        this.scrollToBottom();
                    });
                },
                
                showError(message) {
                    this.addMessage('system', `‚ö†Ô∏è ${message}`);
                },
                
                scrollToBottom() {
                    const messagesDiv = document.getElementById('messages');
                    if (messagesDiv) {
                        messagesDiv.scrollTop = messagesDiv.scrollHeight;
                    }
                },
                
                setupMinimalMode() {
                    const minimalModeCheckbox = document.getElementById('minimalMode');
                    if (minimalModeCheckbox) {
                        const stored = localStorage.getItem('hector_minimal_mode') === 'true';
                        minimalModeCheckbox.checked = stored;
                        this.sidebarVisible = !stored;
                        
                        minimalModeCheckbox.addEventListener('change', (e) => {
                            localStorage.setItem('hector_minimal_mode', e.target.checked);
                            this.sidebarVisible = !e.target.checked;
                        });
                    }
                },
                
                // Cancel ongoing generation
                async cancelGeneration() {
                    // Abort the fetch request first
                    if (this.activeAbortController) {
                        this.activeAbortController.abort();
                        this.activeAbortController = null;
                    }
                    
                    // Reset states
                    this.isTyping = false;
                    this.isGenerating = false;
                    this.activeTaskId = null;
                    
                    // Mark the last agent message as cancelled instead of creating a new message
                    const session = this.sessions[this.currentSessionId];
                    if (session && session.messages.length > 0) {
                        // Find the last agent message
                        for (let i = session.messages.length - 1; i >= 0; i--) {
                            if (session.messages[i].role === 'agent') {
                                session.messages[i].cancelled = true;
                                this.saveSessions();
                                break;
                            }
                        }
                    }
                },
                
                // Streaming handler - Alpine.js state updates
                async sendStreamingMessage(agentUrl, messageText, taskId = null) {
                    const session = this.sessions[this.currentSessionId];
                    if (!session) {
                        this.newChat();
                        return;
                    }
                    
                    const request = {
                        jsonrpc: '2.0',
                        method: 'message/stream',
                        params: {
                            request: {
                                contextId: session.contextId,
                                role: 'user',
                                parts: [{ text: messageText }]
                            }
                        },
                        id: this.generateRequestId()
                    };
                    
                    // Include taskId if provided (for human-in-the-loop prompts)
                    const activeTaskId = taskId || session.taskId || this.activeTaskId;
                    if (activeTaskId) {
                        request.params.request.taskId = activeTaskId;
                    }
                    
                    const url = `${agentUrl}/stream`;
                    
                    // Create agent message state for streaming
                    // Use array instead of Map for Alpine.js reactivity
                    const agentMessage = {
                        id: 'msg-' + Date.now() + '-' + Math.random(),
                        role: 'agent',
                        text: '',
                        metadata: {},
                        toolCalls: [],
                        thinkingBlocks: [],
                        widgets: [], // Array instead of Map for reactivity
                        time: new Date().toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit' })
                    };
                    
                    // Add empty message to start streaming
                    this.sessions[this.currentSessionId].messages.push(agentMessage);
                    const messageIndex = this.sessions[this.currentSessionId].messages.length - 1;
                    // Get reference to the message in the array for direct mutation
                    const messageRef = this.sessions[this.currentSessionId].messages[messageIndex];
                    
                    this.isTyping = true;
                    this.isGenerating = true;
                    this.activeAbortController = new AbortController();
                    
                    try {
                        const response = await fetch(url, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify(request),
                            signal: this.activeAbortController.signal
                        });
                        
                        if (!response.ok) throw new Error(`HTTP ${response.status}`);
                        
                        const reader = response.body.getReader();
                        const decoder = new TextDecoder();
                        let buffer = '';
                        let lastTaskId = null;
                        let sawInputRequired = false; // Track if we saw INPUT_REQUIRED in this stream
                        
                        while (true) {
                            const { done, value } = await reader.read();
                            if (done) break;
                            
                            buffer += decoder.decode(value, { stream: true });
                            const lines = buffer.split('\n');
                            buffer = lines.pop();
                            
                            for (const line of lines) {
                                if (line.startsWith('data: ')) {
                                    try {
                                        const data = JSON.parse(line.substring(6));
                                        if (data.error) {
                                            this.isTyping = false;
                                            this.showError(data.error.message);
                                            throw new Error(data.error.message);
                                        }
                                        
                                        const result = data.result || data;
                                        let message = null;
                                        
                                        // Handle task status updates (for human-in-the-loop prompts)
                                        if (result.statusUpdate) {
                                            const statusUpdate = result.statusUpdate;
                                            if (statusUpdate.status && statusUpdate.status.state === 'TASK_STATE_INPUT_REQUIRED') {
                                                // Task is waiting for user input
                                                this.isTyping = false;
                                                this.isGenerating = false;
                                                
                                                // Store taskId for resuming - CRITICAL for human-in-the-loop
                                                // The approval widget will be displayed through normal message processing below
                                                if (statusUpdate.taskId) {
                                                    this.activeTaskId = statusUpdate.taskId;
                                                    this.sessions[this.currentSessionId].taskId = statusUpdate.taskId;
                                                    this.saveSessions();
                                                    sawInputRequired = true; // Mark that we saw INPUT_REQUIRED
                                                    
                                                    // Focus input field to prompt user
                                                    this.focusInput();
                                                }
                                                
                                                // Don't continue here - let the message processing below handle the approval widget
                                                // The statusUpdate may contain the message with approval widgets
                                            }
                                        }
                                        
                                        // Check if statusUpdate contains a message to process
                                        if (result.statusUpdate && result.statusUpdate.status && result.statusUpdate.status.update) {
                                            message = result.statusUpdate.status.update;
                                        } else if (result.message) {
                                            message = result.message;
                                            if (message.taskId) {
                                                lastTaskId = message.taskId;
                                                this.activeTaskId = message.taskId;
                                                messageRef.metadata.taskId = message.taskId;
                                            }
                                        } else if (result.parts) {
                                            message = result;
                                        }
                                        
                                        const isAgentRole = message && message.parts && 
                                            (message.role === 'agent' || message.role === 'ROLE_AGENT');
                                        
                                        if (isAgentRole) {
                                            // Check if this message contains approval requests first
                                            const currentApprovals = this.extractApprovalFromParts(message.parts);
                                            const hasApprovals = currentApprovals && currentApprovals.length > 0;

                                            // Handle text - but SKIP if message contains approval requests
                                            // Approval prompts are displayed in the widget, not as text
                                            if (hasApprovals) {
                                                // Clear any existing text if this is an approval message
                                                // The prompt text should only appear in the widget, not as separate text
                                                if (messageRef.text) {
                                                    messageRef.text = '';
                                                }
                                            } else {
                                                const text = this.extractTextFromParts(message.parts);
                                                if (text) {
                                                    if (!messageRef.text) {
                                                        messageRef.text = '';
                                                    }
                                                    messageRef.text += text;
                                                }
                                            }

                                            // Handle tool calls
                                            const toolCalls = this.extractToolCallsFromParts(message.parts);
                                            toolCalls.forEach(tc => {
                                                const existingWidget = messageRef.widgets.find(w => w.id === tc.id);
                                                if (!existingWidget) {
                                                    messageRef.widgets.push({
                                                        id: tc.id,
                                                        type: 'tool',
                                                        data: { name: tc.name, args: tc.args },
                                                        status: 'working',
                                                        content: '',
                                                        isExpanded: false
                                                    });
                                                }
                                            });
                                            
                                            // Handle tool results
                                            const toolResults = this.extractToolResultsFromParts(message.parts);
                                            toolResults.forEach(tr => {
                                                const widget = messageRef.widgets.find(w => w.id === tr.tool_call_id);
                                                if (widget) {
                                                    widget.status = tr.success ? 'success' : 'failed';
                                                    if (tr.content) {
                                                        widget.content = tr.content;
                                                    }
                                                }
                                            });
                                            
                                            // Handle thinking blocks
                                            const thinkingBlocks = this.extractThinkingFromParts(message.parts);
                                            thinkingBlocks.forEach(tb => {
                                                const existingWidget = messageRef.widgets.find(w => w.id === tb.id);
                                                if (!existingWidget) {
                                                    messageRef.widgets.push({
                                                        id: tb.id,
                                                        type: 'thinking',
                                                        data: { type: tb.type },
                                                        status: tb.content && tb.content.trim() ? 'completed' : 'active',
                                                        content: tb.content,
                                                        isExpanded: false
                                                    });
                                                } else {
                                                    existingWidget.content += tb.content;
                                                    // CRITICAL: Mark as completed immediately when content exists
                                                    if (existingWidget.content && existingWidget.content.trim()) {
                                                        existingWidget.status = 'completed';
                                                    }
                                                }
                                            });

                                            // Handle approval requests (HITL)
                                            const approvals = this.extractApprovalFromParts(message.parts);
                                            approvals.forEach(approval => {
                                                const existingWidget = messageRef.widgets.find(w => w.id === approval.id);
                                                if (!existingWidget) {
                                                    messageRef.widgets.push({
                                                        id: approval.id,
                                                        type: 'approval',
                                                        data: {
                                                            toolName: approval.toolName,
                                                            toolInput: approval.toolInput,
                                                            options: approval.options
                                                        },
                                                        status: 'pending',
                                                        decision: null,
                                                        isExpanded: true
                                                    });
                                                }
                                            });

                                            // Throttle scroll and highlight updates
                                            this.throttleStreamingUpdate(() => {
                                                this.$nextTick(() => {
                                                    this.scrollToBottom();
                                                    const messagesDiv = document.getElementById('messages');
                                                    if (messagesDiv) {
                                                        const messageElements = messagesDiv.querySelectorAll('[data-message-id]');
                                                        if (messageElements.length > messageIndex) {
                                                            this.highlightCode(messageElements[messageIndex]);
                                                        }
                                                    }
                                                });
                                            });
                                            
                                            // Save sessions periodically during streaming to prevent data loss
                                            this.saveSessions();
                                        }
                                    } catch (err) {
                                        console.error('Parse error:', err);
                                    }
                                }
                            }
                        }
                        
                        // Finalize message
                        this.isTyping = false;
                        this.isGenerating = false;
                        
                        // Focus input when response finishes
                        this.focusInput();
                        
                        // Clear taskId after completion (unless it's INPUT_REQUIRED state)
                        // This prevents resuming completed tasks
                        if (this.sessions[this.currentSessionId].taskId && lastTaskId) {
                            // Only clear if task completed successfully
                            // If task is INPUT_REQUIRED, keep taskId for resuming
                            const session = this.sessions[this.currentSessionId];
                            // Check if we need to keep taskId (will be handled by statusUpdate)
                            // For now, keep it - it will be cleared when task completes
                        }
                        
                        // Final sync - message already mutated during streaming via messageRef
                        if (lastTaskId && messageRef) {
                            messageRef.metadata.taskId = lastTaskId;
                        }
                        
                        // Ensure messageRef is properly saved - CRITICAL for persistence
                        if (messageRef) {
                            // Finalize all widget statuses - mark completed widgets as completed IMMEDIATELY
                            messageRef.widgets.forEach(widget => {
                                if (widget.type === 'tool' && widget.status === 'working') {
                                    widget.status = 'success';
                                }
                                if (widget.type === 'thinking') {
                                    // CRITICAL: Mark as completed if it has content, regardless of current status
                                    if (widget.content && widget.content.trim()) {
                                        widget.status = 'completed';
                                    } else if (widget.status === 'active' && !widget.content) {
                                        // Keep as active only if no content
                                        widget.status = 'active';
                                    }
                                }
                            });
                        }
                        
                        // Highlight code blocks after final render
                        this.$nextTick(() => {
                            const messagesDiv = document.getElementById('messages');
                            if (messagesDiv) {
                                const messageElements = messagesDiv.querySelectorAll('[data-message-id]');
                                if (messageElements.length > messageIndex) {
                                    this.highlightCode(messageElements[messageIndex]);
                                }
                            }
                        });
                        
                        // Update session taskId if present
                        if (lastTaskId) {
                            this.sessions[this.currentSessionId].taskId = lastTaskId;
                        }
                        
                        // Clear taskId only if task completed normally (not INPUT_REQUIRED)
                        // If INPUT_REQUIRED occurred, sawInputRequired will be true and taskId is already set
                        if (!sawInputRequired && this.activeTaskId) {
                            // Task completed normally, clear taskId
                            const session = this.sessions[this.currentSessionId];
                            if (session.taskId === this.activeTaskId) {
                                this.activeTaskId = null;
                                session.taskId = null;
                            }
                        }
                        
                        // CRITICAL: Save sessions immediately after streaming completes
                        // This ensures agent responses persist on refresh
                        this.saveSessions();
                        
                    } catch (err) {
                        this.isTyping = false;
                        this.isGenerating = false;
                        
                        // Save sessions even on error to preserve partial messages
                        if (messageRef) {
                            this.saveSessions();
                        }
                        
                        if (err.name !== 'AbortError' && !err.message.includes('aborted')) {
                            throw err;
                        }
                        console.log('Stream aborted by user');
                    } finally {
                        this.activeTaskId = null;
                        this.activeAbortController = null;
                        // Final save to ensure persistence
                        this.saveSessions();
                    }
                },
                
                generateRequestId() {
                    return Date.now() + '-' + Math.random().toString(36).substr(2, 9);
                },
                
                // Extract functions
                extractToolCallsFromParts(parts) {
                    if (!parts || !Array.isArray(parts)) return [];
                    return parts
                        .filter(part => {
                            if (!part.metadata) return false;
                            return part.metadata.event_type === 'tool_call' && 
                                   !part.metadata.hasOwnProperty('is_error');
                        })
                        .map(part => {
                            const data = part.data?.data || {};
                            const metadata = part.metadata || {};
                            return {
                                id: metadata.tool_call_id || data.id || Math.random().toString(36).substr(2, 9),
                                name: metadata.tool_name || data.name || 'unknown',
                                args: data.arguments || {}
                            };
                        });
                },
                
                extractToolResultsFromParts(parts) {
                    if (!parts || !Array.isArray(parts)) return [];
                    return parts
                        .filter(part => {
                            if (!part.metadata) return false;
                            return part.metadata.event_type === 'tool_call' && 
                                   part.metadata.hasOwnProperty('is_error');
                        })
                        .map(part => {
                            const data = part.data?.data || {};
                            const metadata = part.metadata || {};
                            return {
                                tool_call_id: metadata.tool_call_id || data.tool_call_id,
                                success: !metadata.is_error && (!data.error || data.error === ''),
                                content: data.content || ''
                            };
                        });
                },
                
                extractThinkingFromParts(parts) {
                    if (!parts || !Array.isArray(parts)) return [];
                    
                    const thinkingParts = parts.filter(part => {
                        if (!part.metadata) return false;
                        return part.metadata.event_type === 'thinking' || 
                               part.metadata.block_type === 'thinking';
                    });
                    
                    const thinkingBlocksMap = new Map();
                    
                    thinkingParts.forEach((part, index) => {
                        let content = part.text || '';
                        if (!content && part.data?.data?.text) {
                            content = part.data.data.text;
                        }
                        if (!content) return;
                        
                        const blockId = part.metadata?.block_id || `thinking-${index}`;
                        
                        if (thinkingBlocksMap.has(blockId)) {
                            const existing = thinkingBlocksMap.get(blockId);
                            existing.content += content;
                        } else {
                            thinkingBlocksMap.set(blockId, {
                                id: blockId,
                                content: content,
                                type: part.metadata?.thinking_type || 'default',
                                data: part.data?.data || null,
                                index: part.metadata?.block_index || index
                            });
                        }
                    });
                    
                    return Array.from(thinkingBlocksMap.values());
                },
                
                extractTextFromParts(parts) {
                    if (!parts || !Array.isArray(parts)) return '';
                    
                    // First check if this message contains approval data - if so, skip all text
                    const hasApprovalData = parts.some(part => 
                        part.data?.data?.interaction_type === 'tool_approval'
                    );
                    if (hasApprovalData) {
                        return ''; // Don't extract text from approval messages
                    }
                    
                    return parts.map(part => {
                        // Skip thinking parts from main text
                        if (part.metadata &&
                            (part.metadata.event_type === 'thinking' || part.metadata.block_type === 'thinking')) {
                            return '';
                        }
                        // Skip approval interaction parts - they're rendered as widgets
                        if (part.data?.data?.interaction_type === 'tool_approval') {
                            return '';
                        }
                        if (part.text) {
                            // Filter out approval confirmation messages (redundant - widget already shows status)
                            const text = part.text.trim();
                            if (text.match(/^‚úÖ\s*Approved:\s*.+$/) || text.match(/^üö´\s*Denied:\s*.+$/)) {
                                return '';
                            }
                            return part.text;
                        }
                        if (part.type === 'text' && part.text) {
                            // Filter out approval confirmation messages
                            const text = part.text.trim();
                            if (text.match(/^‚úÖ\s*Approved:\s*.+$/) || text.match(/^üö´\s*Denied:\s*.+$/)) {
                                return '';
                            }
                            return part.text;
                        }
                        if (typeof part === 'string') {
                            // Filter out approval confirmation messages
                            const text = part.trim();
                            if (text.match(/^‚úÖ\s*Approved:\s*.+$/) || text.match(/^üö´\s*Denied:\s*.+$/)) {
                                return '';
                            }
                            return part;
                        }
                        return '';
                    }).filter(t => t).join('\n');
                },

                // Extract approval requests from parts (HITL)
                extractApprovalFromParts(parts) {
                    if (!parts || !Array.isArray(parts)) return [];

                    const approvals = [];
                    parts.forEach((part, index) => {
                        if (part.data?.data) {
                            const data = part.data.data;
                            if (data.interaction_type === 'tool_approval') {
                                approvals.push({
                                    id: `approval-${index}`,
                                    type: 'tool_approval',
                                    toolName: data.tool_name || 'unknown',
                                    toolInput: data.tool_input || '',
                                    options: data.options || ['approve', 'deny']
                                });
                            }
                        }
                    });
                    return approvals;
                },

                // Handle approval decision (approve/deny)
                async handleApproval(widgetId, decision) {
                    const session = this.sessions[this.currentSessionId];
                    if (!session) return;

                    // Find the widget and mark it as decided
                    // Find the message containing this approval widget (should be the last agent message)
                    let messageRef = null;
                    for (let i = session.messages.length - 1; i >= 0; i--) {
                        const msg = session.messages[i];
                        if (msg.role === 'agent' && msg.widgets) {
                            const widget = msg.widgets.find(w => w.id === widgetId);
                            if (widget) {
                                messageRef = msg;
                                widget.decision = decision;
                                widget.status = 'decided';
                                break;
                            }
                        }
                    }

                    // If we didn't find the message, use the last message as fallback
                    if (!messageRef) {
                        messageRef = session.messages[session.messages.length - 1];
                        const widget = messageRef.widgets?.find(w => w.id === widgetId);
                        if (widget) {
                            widget.decision = decision;
                            widget.status = 'decided';
                        }
                    }

                    const messageText = decision;
                    const taskId = session.taskId || this.activeTaskId;

                    if (!this.selectedAgent) return;
                    const agentUrl = this.selectedAgent.url;

                    // Build request matching sendMessage structure
                    const request = {
                        jsonrpc: '2.0',
                        method: 'message/stream',
                        params: {
                            request: {
                                contextId: session.contextId,
                                taskId: taskId,
                                role: 'user',
                                parts: [
                                    { text: messageText },
                                    { data: { data: { decision: messageText } } }
                                ]
                            }
                        },
                        id: this.generateRequestId()
                    };

                    const url = `${agentUrl}/stream`;

                    this.isTyping = true;
                    this.isGenerating = true;
                    this.activeAbortController = new AbortController();

                    let sawInputRequired = false;
                    let lastTaskId = null;

                    // Continue streaming into the existing agent message (the one with the approval widget)
                    // Don't create a new message - the agent response should continue in the same message
                    if (!messageRef || messageRef.role !== 'agent') {
                        // Fallback: create new message only if we couldn't find the right one
                        messageRef = {
                            role: 'agent',
                            text: '',
                            metadata: {},
                            toolCalls: [],
                            thinkingBlocks: [],
                            widgets: [],
                            time: new Date().toLocaleTimeString('en-US', { hour: '2-digit', minute: '2-digit' })
                        };
                        session.messages.push(messageRef);
                    }

                    try {
                        const response = await fetch(url, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify(request),
                            signal: this.activeAbortController.signal
                        });

                        if (!response.ok) throw new Error(`HTTP ${response.status}`);

                        const reader = response.body.getReader();
                        const decoder = new TextDecoder();
                        let buffer = '';

                        while (true) {
                            const { done, value } = await reader.read();
                            if (done) break;

                            buffer += decoder.decode(value, { stream: true });
                            const lines = buffer.split('\n');
                            buffer = lines.pop();

                            for (const line of lines) {
                                if (line.startsWith('data: ')) {
                                    try {
                                        const data = JSON.parse(line.substring(6));

                                        if (data.error) {
                                            this.isTyping = false;
                                            this.showError(data.error.message);
                                            throw new Error(data.error.message);
                                        }

                                        const result = data.result || data;
                                        let message = null;

                                        if (result.message) {
                                            message = result.message;
                                        } else if (result.msg) {
                                            message = result.msg;
                                        }

                                        // Check for both lowercase 'agent' and uppercase 'ROLE_AGENT' (protobuf enum)
                                        const isAgentMessage = message && message.parts &&
                                            (message.role === 'agent' || message.role === 'ROLE_AGENT');

                                        if (isAgentMessage) {
                                            // Check if this message contains approval requests first
                                            const currentApprovals = this.extractApprovalFromParts(message.parts);
                                            const hasApprovals = currentApprovals && currentApprovals.length > 0;

                                            // Handle text - but SKIP if message contains approval requests
                                            // Approval prompts are displayed in the widget, not as text
                                            if (hasApprovals) {
                                                // Clear any existing text if this is an approval message
                                                // The prompt text should only appear in the widget, not as separate text
                                                if (messageRef.text) {
                                                    messageRef.text = '';
                                                }
                                            } else {
                                                const text = this.extractTextFromParts(message.parts);
                                                if (text) {
                                                    if (!messageRef.text) {
                                                        messageRef.text = '';
                                                    }
                                                    messageRef.text += text;
                                                }
                                            }

                                            // Handle tool calls
                                            const toolCalls = this.extractToolCallsFromParts(message.parts);
                                            toolCalls.forEach(tc => {
                                                if (!messageRef.widgets) {
                                                    messageRef.widgets = [];
                                                }
                                                const existingWidget = messageRef.widgets.find(w => w.id === tc.id);
                                                if (!existingWidget) {
                                                    messageRef.widgets.push({
                                                        id: tc.id,
                                                        type: 'tool',
                                                        data: { name: tc.name, args: tc.args },
                                                        status: 'working',
                                                        content: '',
                                                        isExpanded: false
                                                    });
                                                }
                                            });

                                            // Handle tool results
                                            const toolResults = this.extractToolResultsFromParts(message.parts);
                                            toolResults.forEach(tr => {
                                                if (!messageRef.widgets) {
                                                    messageRef.widgets = [];
                                                }
                                                const widget = messageRef.widgets.find(w => w.id === tr.tool_call_id);
                                                if (widget) {
                                                    widget.status = tr.success ? 'success' : 'failed';
                                                    if (tr.content) {
                                                        widget.content = tr.content;
                                                    }
                                                }
                                            });

                                            // Handle thinking blocks
                                            const thinkingBlocks = this.extractThinkingFromParts(message.parts);
                                            thinkingBlocks.forEach(tb => {
                                                if (!messageRef.widgets) {
                                                    messageRef.widgets = [];
                                                }
                                                const existingWidget = messageRef.widgets.find(w => w.id === tb.id);
                                                if (!existingWidget) {
                                                    messageRef.widgets.push({
                                                        id: tb.id,
                                                        type: 'thinking',
                                                        data: { type: tb.type },
                                                        status: tb.content && tb.content.trim() ? 'completed' : 'active',
                                                        content: tb.content,
                                                        isExpanded: false
                                                    });
                                                } else {
                                                    existingWidget.content += tb.content;
                                                    if (existingWidget.content && existingWidget.content.trim()) {
                                                        existingWidget.status = 'completed';
                                                    }
                                                }
                                            });

                                            this.throttleStreamingUpdate(() => {
                                                this.$nextTick(() => {
                                                    this.scrollToBottom();
                                                });
                                            });

                                            this.saveSessions();
                                        }
                                    } catch (err) {
                                        console.error('Parse error:', err);
                                    }
                                }
                            }
                        }

                        this.isTyping = false;
                        this.isGenerating = false;
                        this.saveSessions();
                        
                        // Focus input when response finishes
                        this.focusInput();

                    } catch (err) {
                        this.isTyping = false;
                        this.isGenerating = false;

                        if (err.name !== 'AbortError' && !err.message.includes('aborted')) {
                            throw err;
                        }
                        console.log('Stream aborted by user');
                    } finally {
                        if (!sawInputRequired) {
                            this.activeTaskId = null;
                        }
                        this.activeAbortController = null;
                        this.saveSessions();
                    }
                }
            };
        }
    </script>
</body>
</html>
