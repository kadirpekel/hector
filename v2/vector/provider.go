// Copyright 2025 Kadir Pekel
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Package vector provides a unified interface for vector database operations.
//
// This package abstracts vector storage and similarity search, allowing
// different backends (chromem-go, Qdrant, Chroma, etc.) to be used
// interchangeably. It serves as the foundation for both:
//   - Long-term memory (session/conversation search)
//   - RAG (document retrieval)
//
// # Architecture (ported from legacy pkg/databases)
//
// The package follows a provider pattern:
//
//	┌─────────────────────────────────────────────────────────────────────┐
//	│  Provider Interface                                                  │
//	│  • Upsert, Search, Delete operations                                │
//	│  • Collection management                                            │
//	│  • Metadata filtering                                               │
//	├─────────────────────────────────────────────────────────────────────┤
//	│  Implementations                                                     │
//	│  ┌─────────────┐ ┌─────────────┐ ┌─────────────┐ ┌─────────────┐   │
//	│  │ ChromemProv │ │ QdrantProv  │ │ ChromaProv  │ │ PineconePr  │   │
//	│  │ (embedded)  │ │ (external)  │ │ (external)  │ │ (cloud)     │   │
//	│  └─────────────┘ └─────────────┘ └─────────────┘ └─────────────┘   │
//	└─────────────────────────────────────────────────────────────────────┘
//
// # Usage
//
// The typical flow is:
//  1. Create a provider from configuration
//  2. Use with SearchEngine (v2/search) for high-level operations
//  3. SearchEngine handles embedding generation and query processing
//
// Example:
//
//	provider, _ := vector.NewChromemProvider(vector.ChromemConfig{
//	    PersistPath: ".hector/vectors",
//	})
//	defer provider.Close()
//
//	// Upsert with pre-computed vector
//	provider.Upsert(ctx, "documents", "doc1", embedding, metadata)
//
//	// Search with query vector
//	results, _ := provider.Search(ctx, "documents", queryVector, 10)
package vector

import (
	"context"
	"io"
)

// Provider defines the interface for vector database operations.
//
// All implementations must be thread-safe for concurrent access.
// Vector dimensions are determined by the embedder used and should
// be consistent within a collection.
//
// Derived from legacy pkg/databases/registry.go:DatabaseProvider
type Provider interface {
	// Upsert adds or updates a document with its vector embedding.
	//
	// If a document with the same ID exists, it will be updated.
	// The vector dimension must match the collection's configured dimension.
	//
	// Parameters:
	//   - collection: logical grouping (e.g., "memory", "documents")
	//   - id: unique document identifier
	//   - vector: embedding vector from the embedder
	//   - metadata: additional searchable/filterable attributes
	Upsert(ctx context.Context, collection string, id string, vector []float32, metadata map[string]any) error

	// Search finds the most similar vectors in a collection.
	//
	// Returns results ordered by similarity score (highest first).
	// The query vector should be generated by the same embedder
	// used for indexing.
	//
	// Parameters:
	//   - collection: which collection to search
	//   - vector: query embedding vector
	//   - topK: maximum number of results to return
	Search(ctx context.Context, collection string, vector []float32, topK int) ([]Result, error)

	// SearchWithFilter combines vector similarity with metadata filtering.
	//
	// The filter map supports equality matching on metadata fields.
	// Filter semantics:
	//   - {"field": "value"} - exact match
	//   - {"field1": "v1", "field2": "v2"} - AND of all conditions
	//
	// Example:
	//   filter := map[string]any{"user_id": "user123", "type": "document"}
	SearchWithFilter(ctx context.Context, collection string, vector []float32, topK int, filter map[string]any) ([]Result, error)

	// Delete removes a document from a collection by ID.
	Delete(ctx context.Context, collection string, id string) error

	// DeleteByFilter removes all documents matching the filter.
	//
	// Use with caution - this can delete many documents at once.
	DeleteByFilter(ctx context.Context, collection string, filter map[string]any) error

	// CreateCollection creates a new collection with specified vector dimension.
	//
	// Some backends create collections implicitly on first Upsert.
	// This method allows explicit creation with configuration.
	CreateCollection(ctx context.Context, collection string, vectorDimension int) error

	// DeleteCollection removes a collection and all its documents.
	DeleteCollection(ctx context.Context, collection string) error

	// Name returns the provider implementation name (e.g., "chromem", "qdrant").
	Name() string

	// Close releases resources held by the provider.
	// Should be called when the provider is no longer needed.
	io.Closer
}

// Result represents a single search result.
//
// Results are returned ordered by Score (highest first).
// The Score semantics depend on the implementation:
//   - Cosine similarity: 0.0 to 1.0 (1.0 = identical)
//   - Euclidean distance: inverted (higher = more similar)
type Result struct {
	// ID is the unique document identifier.
	ID string

	// Score represents similarity/relevance (higher is better).
	Score float32

	// Content is the original text content (if stored in metadata).
	Content string

	// Vector is the document's embedding (optional, not always returned).
	Vector []float32

	// Metadata contains the document's metadata fields.
	Metadata map[string]any
}

// Config is the base configuration for all vector providers.
type Config struct {
	// Type identifies the provider implementation.
	// Values: "chromem", "qdrant", "chroma", "pinecone", "milvus", "weaviate"
	Type string `yaml:"type"`

	// Collection is the default collection name.
	// Individual operations can override this.
	Collection string `yaml:"collection,omitempty"`
}

// NilProvider is a no-op implementation for when vector search is disabled.
type NilProvider struct{}

func (NilProvider) Upsert(ctx context.Context, collection string, id string, vector []float32, metadata map[string]any) error {
	return nil
}

func (NilProvider) Search(ctx context.Context, collection string, vector []float32, topK int) ([]Result, error) {
	return []Result{}, nil
}

func (NilProvider) SearchWithFilter(ctx context.Context, collection string, vector []float32, topK int, filter map[string]any) ([]Result, error) {
	return []Result{}, nil
}

func (NilProvider) Delete(ctx context.Context, collection string, id string) error {
	return nil
}

func (NilProvider) DeleteByFilter(ctx context.Context, collection string, filter map[string]any) error {
	return nil
}

func (NilProvider) CreateCollection(ctx context.Context, collection string, vectorDimension int) error {
	return nil
}

func (NilProvider) DeleteCollection(ctx context.Context, collection string) error {
	return nil
}

func (NilProvider) Name() string {
	return "nil"
}

func (NilProvider) Close() error {
	return nil
}

// Ensure NilProvider implements Provider.
var _ Provider = NilProvider{}
